#### 总结：

##### 为什么要用二进制保存集合？

​	因为状态不是向数字三角形模型那样确定的，而是有2*n种状态，因此要保存集合并判断集合的转移关系。



当前点只能由前面的点转移时， 要先枚举点； 没有顺序时， 先枚举状态；

#### 位运算

```
// 枚举所有子集
for(int i = 0; i < 1 << n; i++)
// 枚举状态A的子集
for(int s = A; s ; s = (s-1)&A)
// 把某位置1
i | (1 << j)
// 某位 置0
i & ~(1 << j)  如果j位确定是1， i ^(1 << j)
//求某状态的补集
i ^ (1 << n) - 1
// b 是a的子集
(a&b) == b
// lowbit
x&(-x)
// 去掉最低位的1
x&(x-1) 可用来判断是否是2的幂 x&(x-1) == 0
```

#### 例题：

91. #### 最短Hamilton路径

给定一张 n 个点的带权无向图，点从 0~n-1 标号，求起点 0 到终点 n-1 的最短Hamilton路径。 Hamilton路径的定义是从 0 到 n-1 不重不漏地经过每个点恰好一次。

```cpp
int f[1<<20][20];
int g[25][25];
signed main(){
    int n;
    cin >> n;
    for(int i = 0; i < n; i++)
        for(int j = 0; j < n; j++) read(g[i][j]);
    mset(f, 0x3f);// 由于要求最小值，所以这里将 f 初始化为正无穷会更好处理一些
    f[1][0] = 0; // 因为题目要求从点 0 出发，所以这里要将 经过点集为 1，当前到达第 0 个点 的最短路径初始化为 0
    for (int i=1; i<(1<<n); i++)//i代表着是一个方案集合，其中每一个位置1和0，代表着这个点经过还是没有经过
        for (int j=0; j<n; j++)//枚举当前到了哪一个点
            if ((i>>j & 1))//如果i集合中第j位是1，也就是到达过这个点
            for (int k=0; k<n; k++)//枚举到达j的点k
            f[i][j]=min(f[i][j],f[i^(1<<j)][k]+g[k][j]);//选择最小值，也就是判断，k点到j点最优，还是以前的方案最优
    print(f[(1<<n) -1][n-1]);
    return 0;
}

//第二次*******************************************
	mset(f, inf);
    f[1][0] = 0;
    for(int i = 0; i < 1 << n; i++){
        for(int j = 0; j < n; j++){
            if(i >> j&1)
            for(int k = 0; k < n; k++){
                if(i >> k&1){
                    f[i][j] = min(f[i][j], f[i ^ (1 << j) ][k] + g[k][j]);
                }
            }
        }
    }
    cout << f[(1 << n) - 1][n-1];
```

291. #### 蒙德里安的梦想

求把N**M的棋盘分割成若干个1*2的的长方形，有多少种方案。

例如当N=2，M=4时，共有5种方案。当N=2，M=3时，共有3种方案。

如下图所示：

![2411_1.jpg](https://i.loli.net/2020/09/18/wS6ZitzEhsuUdyx.gif)

```cpp
const int N = 12, M = 1 << N;
int f[N][M];
int st[M];
signed main(){
    int n, m;
    while(cin >> n >> m, n|| m){
        for(int i = 0;i < 1 << n; i++){
            int cnt = 0;//用来记录连续的0的个数
            st[i] = true;//记录这个状态被枚举过且可行
            for (int j = 0; j < n; j ++ )//从低位到高位枚举它的每一位
                if (i >> j & 1)//如果为1
                {
                    if (cnt & 1) st[i] = false;//如果之前连续0的个数是奇数，竖的方块插不进来，这种状态不行
                    cnt = 0;//清空计数器
                }
                else cnt ++ ;//如果不为1，计数器+1
            if (cnt & 1) st[i] = false;//到末尾再判断一下前面0的个数是否为奇数，同前
        }
        memset(f, 0, sizeof f);//一定要记得初始化成0，对于每个新的输入要重新计算f[N][M]
        f[0][0] = 1;
        for (int i = 1; i <= m; i ++ )//对于每一列
            for (int j = 0; j < 1 << n; j ++ )//枚举j的状态
                for (int k = 0; k < 1 << n; k ++ )//再枚举前一行的伸出状态k
                    if ((j & k) == 0 && st[j | k])//如果它们没有冲突，i这一列被占位的情况也是合法的话
                        f[i][j] += f[i - 1][k];//那么这种状态下它的方案数等于之前每种k状态数目的和

        cout << f[m][0] << endl;//求的是第m行排满，并且第m行不向外伸出块的情况
    } 
    return 0;
    
}
```

