#### 区间问题：

##### 最大的区间不相交数量

按右端点排序， 如果不重叠（左端点大于上个点的右端点）则加上一个区间

```cpp
int pre = -inf;
int cnt = 0;
rep(i, 1, n){
    if(p[i].fi > pre) {
        cnt++; pre = p[i].se;
    }
}
```

##### 区间分组

按左端点排序

找到满足分组右端点小于区间左端点的分组， 如果无，则开辟新的分组

```cpp
pqueue<int, vector<int>, greater<int>> pq;
sort(p+1, p+1+n);
rep(i, 1, n){
    if(pq.size() && pq.top() < p[i].fi) pq.pop(); //如果有，则更新分组的右端点。
    pq.push(p[i].se); //开辟新的分组和更新分组的右端点是一样的操作
}
```

##### 区间覆盖

>  给定N个闭区间以及一个线段区间，请你选择尽量少的区间，将指定线段区间完全覆盖。

按左端点排序

在左右能覆盖start点的区间中，选右端点最大的区间，start更新为这个右端点

```cpp

```

#### 绝对值不等式

##### 货仓选址

$$
\begin{aligned}
&| x_1 - x| +| x_2 - x| + ...+ |x_n-x| = (|x_1 - x| + |x_n-x|) + (...)\\
&而 (|a - x| + |b-x| )的最小值为(b - a) , x可取[a,b]之间任意一点，\\
&n/2组都满足的条件下x取中位数
\end{aligned}
$$

#### 推公式

##### 耍杂技的牛

由两头牛之间的关系推广到所有头牛中
$$
\begin{aligned}
&第一头牛 w1, s1; \qquad第二头牛 w2, s2;\\
& 如果第一头牛在上面， 则\\
& w1 - s2 < w2 - s1 ;推出 w1 + s1 < w2 +s2
\end{aligned}
$$
